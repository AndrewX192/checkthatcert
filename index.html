<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Check That Certificate : Code samples that correctly check the remote server&#39;s SSL certificate">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Check That Certificate</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/AndrewX192/checkthatcert">View on GitHub</a>

          <h1 id="project_title">Check That Certificate</h1>
          <h2 id="project_tagline">Code samples that correctly check the remote server&#39;s SSL certificate</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/AndrewX192/checkthatcert/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/AndrewX192/checkthatcert/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="check-that-cert" class="anchor" href="#check-that-cert" aria-hidden="true"><span class="octicon octicon-link"></span></a>Check That Cert!</h1>

<p>Unless you verify who you are talking to, having an encrypted channel won't provide you confidentiality or integrity. Not checking the SSL certificate of a remote server you are communicating with allows anyone with control of the network to stand up their own server and certificate, impersonating your server.</p>

<p>Check That Cert is an attempt to document usage of TLS libraries that perform correct certificate checking.</p>
        <h1>
<a id="check-that-cert" class="anchor" href="#check-that-cert" aria-hidden="true"><span class="octicon octicon-link"></span></a>At BSidesLV</h1>

<p>Check that Certificate will be presented at <a href="http://bsideslv2015.sched.org/event/7c5064a2f17947bbd890e249cbc641be">BSidesLV 2015</a></p>

<h1>
<a id="self-signed-certificates-vs-certificates-signed-by-a-certificate-authority" class="anchor" href="#self-signed-certificates-vs-certificates-signed-by-a-certificate-authority" aria-hidden="true"><span class="octicon octicon-link"></span></a>Self signed certificates vs certificates signed by a certificate authority</h1>

<p>Self signed certificates are certificates that are not signed by a trusted authority, in other words - no "trusted" third party has vouched for these certificates. These certificates should never be trusted without explicitly verifying that the certificate of the remote server is the server you intend to communicate with. Certificates signed by a certificate authority can be verified by ensuring that a trusted certificate authority signed that certificate. When you need to communicate with a specific server, you'll want to ensure that your client is set to only trust certificate the server is presenting, rather than any certificate signed by a certificate authority. When you have many users who will use standard software you do not have control of (for example, a web browser), you'll want to submit a certificate signing request to a certificate authority to obtain a proper certificate.</p>

<h1>
<a id="generating-a-self-signed-certificate" class="anchor" href="#generating-a-self-signed-certificate" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generating a self signed certificate</h1>

<pre><code>openssl genrsa -out server.pem 4096
openssl req -new -x509 -key server.pem -out cert.pem -days 30
</code></pre>

<p>Sample output:</p>

<pre><code>[user@localhost testcase]$ openssl genrsa -out server.pem 4096
Generating RSA private key, 4096 bit long modulus
....................................................................................++
...........................++
e is 65537 (0x10001)
[user@localhost testcase]$ openssl req -new -x509 -key server.pem -out cert.pem -days 30
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:US
State or Province Name (full name) []:Washington
Locality Name (eg, city) [Default City]:Seattle
Organization Name (eg, company) [Default Company Ltd]:Check That Cert
Organizational Unit Name (eg, section) []:Testcases
Common Name (eg, your name or your server's hostname) []:localhost
Email Address []:someone@example.com
[user@localhost testcase]$ 
</code></pre>

<h2>
<a id="hosting-a-simple-server-to-test-encrypted-communication" class="anchor" href="#hosting-a-simple-server-to-test-encrypted-communication" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hosting a simple server to test encrypted communication</h2>

<pre><code>openssl s_server -tls1 -tls1_1 -tls1_2 -key server.pem -cert cert.pem -www
</code></pre>

<h1>
<a id="what-needs-verification" class="anchor" href="#what-needs-verification" aria-hidden="true"><span class="octicon octicon-link"></span></a>What needs verification?</h1>

<h2>
<a id="hostname" class="anchor" href="#hostname" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hostname</h2>

<p>The hostname (or CN) is a commonly accepted way of identifying the name of the system you are communicating with. In the event that an attacker redirects your traffic to another system trusted by client, validation of the hostname will prevent the transport from operating to the incorrect service.</p>

<h2>
<a id="issuer" class="anchor" href="#issuer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Issuer</h2>

<p>The Issuer is the name of the authority vouching for a certificate. It is important that this is bound to certificate that is present on the system and not simply a string comparison of the Subject name.</p>

<h2>
<a id="valid-from-to-timestamps" class="anchor" href="#valid-from-to-timestamps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Valid from-to timestamps</h2>

<p>In order to ensure that a certificate isn't used beyond it's expiration, the valid-to timestamp should be verified against the machine's time. In order to prevent the system from trusting an expired certificate when the clock is wrong, the valid-from timestamp should be verified. Short lived certificates can reduce the chance of an attacker being able to use a certificate should they be able to compromise it. </p>

<h2>
<a id="extended-key-use" class="anchor" href="#extended-key-use" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extended Key Use</h2>

<h1>
<a id="pitfalls-to-certificate-validation" class="anchor" href="#pitfalls-to-certificate-validation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pitfalls to certificate validation</h1>

<h2>
<a id="not-checking-the-certificate" class="anchor" href="#not-checking-the-certificate" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not checking the certificate</h2>

<p>Failure to check the certificate means your client will communicate with any server using that transport. If you send secrets over the channel, it is trivial for an attacker with the ability to redirect network traffic to read them.</p>

<h2>
<a id="trusting-more-than-the-server-you-need-to-communicate-with" class="anchor" href="#trusting-more-than-the-server-you-need-to-communicate-with" aria-hidden="true"><span class="octicon octicon-link"></span></a>Trusting more than the server you need to communicate with</h2>

<p>The more certificates and certificate authorities you trust, the higher the chance of your transport being intercepted. Limit the parties you trust and review them frequently to ensure you still trust them. </p>

<h2>
<a id="not-checking-to-see-if-the-certificate-is-expired" class="anchor" href="#not-checking-to-see-if-the-certificate-is-expired" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not checking to see if the certificate is expired</h2>

<p>Certificates are intended to be live for a finite period of time. Having certificates expire ensures that systems will not trust the certificate forever if it is compromised, lost, or revoked.</p>

<h2>
<a id="not-checking-a-certificate-revocation-list" class="anchor" href="#not-checking-a-certificate-revocation-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not checking a certificate revocation list</h2>

<p>In some cases, checking the CRL is a critical step to ensuring that the certificate should be trusted. This is particularly important for remote access software that uses client-certificates to perform authentication, and is less interesting for environments where a client uses a CRL to verify whether or not the server's certificate has expired, as an attacker can who can MiTM the SSL communication can also prevent the CRL from being downloaded and communication will continue as normal.</p>

<h1>
<a id="beyond-certificate-checking" class="anchor" href="#beyond-certificate-checking" aria-hidden="true"><span class="octicon octicon-link"></span></a>Beyond Certificate Checking</h1>

<p>The scope of this project is currently to identify how to properly check the authenticity of the remote server. Future work includes identifying places where weaknesses exist within the TLS client implementation or configuration.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Check That Certificate</p>
      </footer>
    </div>

  </body>
</html>
