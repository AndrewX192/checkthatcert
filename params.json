{"name":"Check That Certificate","tagline":"Code samples that correctly check the remote server's SSL certificate","body":"Check That Cert!\r\n=============\r\n\r\nUnless you verify who you are talking to, having an encrypted channel won't provide you confidentiality or integrity. Not checking the SSL certificate of a remote server you are communicating with allows anyone with control of the network to stand up their own server and certificate, impersonating your server.\r\n\r\nCheck That Cert is an attempt to document usage of TLS libraries that perform correct certificate checking.\r\n\r\n# Self signed certificates vs certificates signed by a certificate authority\r\n\r\nSelf signed certificates are certificates that are not signed by a trusted authority, in other words - no \"trusted\" third party has vouched for these certificates. These certificates should never be trusted without explicitly verifying that the certificate of the remote server is the server you intend to communicate with. Certificates signed by a certificate authority can be verified by ensuring that a trusted certificate authority signed that certificate. When you need to communicate with a specific server, you'll want to ensure that your client is set to only trust certificate the server is presenting, rather than any certificate signed by a certificate authority. When you have many users who will use standard software you do not have control of (for example, a web browser), you'll want to submit a certificate signing request to a certificate authority to obtain a proper certificate.\r\n\r\n# Generating a self signed certificate\r\n\r\n````\r\nopenssl genrsa -out server.pem 4096\r\nopenssl req -new -x509 -key server.pem -out cert.pem -days 30\r\n````\r\n\r\nSample output:\r\n\r\n````\r\n[user@localhost testcase]$ openssl genrsa -out server.pem 4096\r\nGenerating RSA private key, 4096 bit long modulus\r\n....................................................................................++\r\n...........................++\r\ne is 65537 (0x10001)\r\n[user@localhost testcase]$ openssl req -new -x509 -key server.pem -out cert.pem -days 30\r\nYou are about to be asked to enter information that will be incorporated\r\ninto your certificate request.\r\nWhat you are about to enter is what is called a Distinguished Name or a DN.\r\nThere are quite a few fields but you can leave some blank\r\nFor some fields there will be a default value,\r\nIf you enter '.', the field will be left blank.\r\n-----\r\nCountry Name (2 letter code) [XX]:US\r\nState or Province Name (full name) []:Washington\r\nLocality Name (eg, city) [Default City]:Seattle\r\nOrganization Name (eg, company) [Default Company Ltd]:Check That Cert\r\nOrganizational Unit Name (eg, section) []:Testcases\r\nCommon Name (eg, your name or your server's hostname) []:localhost\r\nEmail Address []:someone@example.com\r\n[user@localhost testcase]$ \r\n````\r\n\r\n## Hosting a simple server to test encrypted communication\r\n\r\n````\r\nopenssl s_server -tls1 -tls1_1 -tls1_2 -key server.pem -cert cert.pem -www\r\n````\r\n\r\n\r\n# What needs verification?\r\n\r\n## Hostname\r\n\r\nThe hostname (or CN) is a commonly accepted way of identifying the name of the system you are communicating with. In the event that an attacker redirects your traffic to another system trusted by client, validation of the hostname will prevent the transport from operating to the incorrect service.\r\n\r\n## Issuer\r\n\r\nThe Issuer is the name of the authority vouching for a certificate. It is important that this is bound to certificate that is present on the system and not simply a string comparison of the Subject name.\r\n\r\n## Valid from-to timestamps\r\n\r\nIn order to ensure that a certificate isn't used beyond it's expiration, the valid-to timestamp should be verified against the machine's time. In order to prevent the system from trusting an expired certificate when the clock is wrong, the valid-from timestamp should be verified. Short lived certificates can reduce the chance of an attacker being able to use a certificate should they be able to compromise it. \r\n\r\n## Extended Key Use\r\n\r\n# Pitfalls to certificate validation\r\n\r\n## Not checking the certificate\r\n\r\nFailure to check the certificate means your client will communicate with any server using that transport. If you send secrets over the channel, it is trivial for an attacker with the ability to redirect network traffic to read them.\r\n\r\n## Trusting more than the server you need to communicate with\r\n\r\nThe more certificates and certificate authorities you trust, the higher the chance of your transport being intercepted. Limit the parties you trust and review them frequently to ensure you still trust them. \r\n\r\n## Not checking to see if the certificate is expired\r\n\r\nCertificates are intended to be live for a finite period of time. Having certificates expire ensures that systems will not trust the certificate forever if it is compromised, lost, or revoked.\r\n\r\n## Not checking a certificate revocation list\r\n\r\nIn some cases, checking the CRL is a critical step to ensuring that the certificate should be trusted. This is particularly important for remote access software that uses client-certificates to perform authentication, and is less interesting for environments where a client uses a CRL to verify whether or not the server's certificate has expired, as an attacker can who can MiTM the SSL communication can also prevent the CRL from being downloaded and communication will continue as normal.\r\n\r\n# Beyond Certificate Checking\r\n\r\nThe scope of this project is currently to identify how to properly check the authenticity of the remote server. Future work includes identifying places where weaknesses exist within the TLS client implementation or configuration.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}